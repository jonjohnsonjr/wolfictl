package bundle

import (
	"archive/tar"
	"bytes"
	"fmt"
	"io"
	"io/fs"
	"strings"
	"text/template"

	"chainguard.dev/apko/pkg/build/types"
	"chainguard.dev/melange/pkg/config"
	"github.com/google/go-containerregistry/pkg/name"
	v1 "github.com/google/go-containerregistry/pkg/v1"
	"github.com/google/go-containerregistry/pkg/v1/empty"
	"github.com/google/go-containerregistry/pkg/v1/mutate"
	"github.com/google/go-containerregistry/pkg/v1/partial"
	"github.com/google/go-containerregistry/pkg/v1/tarball"
	"github.com/wolfi-dev/wolfictl/pkg/dag"
	"golang.org/x/exp/maps"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"knative.dev/pkg/ptr"
)

type Entrypoint struct {
	File  string
	Flags []string
}

const entrypointTemplate = `# generated by wolfictl build
set -eux

melange build {{.File}} \
{{ range .Flags }} {{.}} \{{end}}

tar -czvf packages.tar.gz ./packages

curl -X PUT --data-binary @packages.tar.gz $PACKAGES_UPLOAD_URL

sha256sum packages.tar.gz
`

var entrypointTmpl *template.Template

func init() {
	entrypointTmpl = template.Must(template.New("entrypointTemplate").Parse(entrypointTemplate))
}

func renderEntrypoint(entrypoint *Entrypoint) (v1.Layer, error) {
	var tbuf bytes.Buffer
	tw := tar.NewWriter(&tbuf)

	var ebuf bytes.Buffer
	if err := entrypointTmpl.Execute(&ebuf, entrypoint); err != nil {
		return nil, err
	}

	eb := ebuf.Bytes()

	hdr := &tar.Header{
		Name: "entrypoint.sh",
		Mode: 0755,
		Size: int64(len(eb)),
	}
	if err := tw.WriteHeader(hdr); err != nil {
		return nil, err
	}

	if _, err := tw.Write(eb); err != nil {
		return nil, err
	}

	if err := tw.Close(); err != nil {
		return nil, err
	}

	opener := func() (io.ReadCloser, error) {
		return io.NopCloser(bytes.NewReader(tbuf.Bytes())), nil
	}

	return tarball.LayerFromOpener(opener)
}

// todo: optimize this if it matters (it probably doesn't)
func layer(srcfs fs.FS) (v1.Layer, error) {
	var buf bytes.Buffer

	tw := tar.NewWriter(&buf)
	if err := tw.AddFS(srcfs); err != nil {
		return nil, err
	}

	if err := tw.Close(); err != nil {
		return nil, err
	}

	opener := func() (io.ReadCloser, error) {
		return io.NopCloser(bytes.NewReader(buf.Bytes())), nil
	}

	return tarball.LayerFromOpener(opener)
}

func New(config *dag.Configuration, base v1.ImageIndex, entrypoints map[string]*Entrypoint, commonfiles, srcfs fs.FS) (v1.ImageIndex, error) {
	m, err := base.IndexManifest()
	if err != nil {
		return nil, err
	}

	wantArchs := map[string]struct{}{}
	for arch := range entrypoints {
		wantArchs[types.ParseArchitecture(arch).ToAPK()] = struct{}{}
	}

	var idx v1.ImageIndex = empty.Index

	for _, desc := range m.Manifests {
		arch := types.ParseArchitecture(desc.Platform.Architecture).ToAPK()
		if _, ok := wantArchs[arch]; !ok {
			continue
		}

		baseImg, err := base.Image(desc.Digest)
		if err != nil {
			return nil, err
		}

		commonLayer, err := layer(commonfiles)
		if err != nil {
			return nil, err
		}

		sourceLayer, err := layer(srcfs)
		if err != nil {
			return nil, err
		}

		entrypoint, ok := entrypoints[arch]
		if !ok {
			return nil, fmt.Errorf("unexpected arch %q for entrypoints: %v", arch, maps.Keys(entrypoints))
		}

		entrypointLayer, err := renderEntrypoint(entrypoint)
		if err != nil {
			return nil, err
		}

		img, err := mutate.AppendLayers(baseImg, commonLayer, sourceLayer, entrypointLayer)
		if err != nil {
			return nil, err
		}

		cf, err := img.ConfigFile()
		if err != nil {
			return nil, err
		}

		cf.Config.Entrypoint = []string{"/bin/sh", "entrypoint.sh"}

		img, err = mutate.ConfigFile(img, cf)
		if err != nil {
			return nil, err
		}

		newDesc, err := partial.Descriptor(img)
		if err != nil {
			return nil, err
		}

		newDesc.Platform = desc.Platform

		idx = mutate.AppendManifests(idx, mutate.IndexAddendum{
			Add:        img,
			Descriptor: *newDesc,
		})
	}

	return idx, nil
}

// escapeRFC1123 escapes a string to be RFC1123 compliant.  We don't worry about
// being collision free because these are generally fed to generateName which
// appends a randomized suffix.
func escapeRFC1123(name string) string {
	return strings.ReplaceAll(strings.ReplaceAll(name, ".", "-"), "_", "-")
}

// Podspec returns bytes of yaml representing a podspec.
// This is a terrible API that we should change.
func Podspec(cfg *dag.Configuration, ref name.Reference, arch string) *corev1.Pod {
	goarch := types.ParseArchitecture(arch).String()

	resources := cfg.Package.Resources
	if resources == nil {
		resources = &config.Resources{}
	}

	// Set some sane default resource requests if none are specified by flag or config.
	// This is required for GKE Autopilot.
	if resources.CPU == "" {
		resources.CPU = "2"
	}
	if resources.Memory == "" {
		resources.Memory = "4Gi"
	}

	rr := corev1.ResourceRequirements{
		Requests: corev1.ResourceList{
			corev1.ResourceCPU:    resource.MustParse(resources.CPU),
			corev1.ResourceMemory: resource.MustParse(resources.Memory),
		},
	}

	pod := &corev1.Pod{
		ObjectMeta: metav1.ObjectMeta{
			GenerateName: fmt.Sprintf("melange-builder-%s-%s-", escapeRFC1123(cfg.Package.Name), arch),
			Namespace:    "default",
			Labels: map[string]string{
				"kubernetes.io/arch":             goarch,
				"app.kubernetes.io/component":    cfg.Package.Name,
				"melange.chainguard.dev/arch":    goarch,
				"melange.chainguard.dev/package": cfg.Package.Name,
			},
			Annotations: map[string]string{},
		},
		Spec: corev1.PodSpec{
			// Don't putz around for 30s when we kill things.
			TerminationGracePeriodSeconds: ptr.Int64(0),
			Containers: []corev1.Container{{
				Name:  "workspace",
				Image: ref.String(),
				// TODO: Do we need this??
				// ldconfig is run to prime ld.so.cache for glibc packages which require it.
				// Command:      []string{"/bin/sh", "-c", "[ -x /sbin/ldconfig ] && /sbin/ldconfig /lib || true\nsleep infinity"},
				Resources:    rr,
				VolumeMounts: []corev1.VolumeMount{},
			}},
			RestartPolicy:                corev1.RestartPolicyNever,
			AutomountServiceAccountToken: ptr.Bool(false),
			NodeSelector: map[string]string{
				"kubernetes.io/arch": goarch,
			},
			ServiceAccountName: "default",
			SecurityContext: &corev1.PodSecurityContext{
				SeccompProfile: &corev1.SeccompProfile{
					Type: corev1.SeccompProfileTypeRuntimeDefault,
				},
			},
			Volumes: []corev1.Volume{},
		},
	}

	for k, v := range cfg.Environment.Environment {
		pod.Spec.Containers[0].Env = append(pod.Spec.Containers[0].Env, corev1.EnvVar{
			Name:  k,
			Value: v,
		})
	}

	return pod
}
