package bundle

import (
	"archive/tar"
	"bytes"
	"fmt"
	"io"
	"io/fs"
	"strings"
	"text/template"

	"chainguard.dev/apko/pkg/build/types"
	"github.com/google/go-containerregistry/pkg/name"
	v1 "github.com/google/go-containerregistry/pkg/v1"
	"github.com/google/go-containerregistry/pkg/v1/empty"
	"github.com/google/go-containerregistry/pkg/v1/mutate"
	"github.com/google/go-containerregistry/pkg/v1/partial"
	"github.com/google/go-containerregistry/pkg/v1/tarball"
	"github.com/wolfi-dev/wolfictl/pkg/dag"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"knative.dev/pkg/ptr"
)

type Entrypoint struct {
	File  string
	Flags []string
}

const entrypointTemplate = `# generated by wolfictl build
set -eux

melange build {{.File}} \
{{ range .Flags }} {{.}} \{{end}}

tar -czvf packages.tar.gz ./packages

curl -X PUT --data-binary @packages.tar.gz $PACKAGES_UPLOAD_URL

sha256sum packages.tar.gz
`

var entrypointTmpl *template.Template

func init() {
	entrypointTmpl = template.Must(template.New("entrypointTemplate").Parse(entrypointTemplate))
}

func entrypoint(w io.Writer, flags []string) error {
	return entrypointTmpl.Execute(w, flags)
}

// todo: optimize this if it matters (it probably doesn't)
func layer(srcfs fs.FS) (v1.Layer, error) {
	var buf bytes.Buffer

	tw := tar.NewWriter(&buf)
	if err := tw.AddFS(srcfs); err != nil {
		return nil, err
	}

	if err := tw.Close(); err != nil {
		return nil, err
	}

	opener := func() (io.ReadCloser, error) {
		return io.NopCloser(bytes.NewReader(buf.Bytes())), nil
	}

	return tarball.LayerFromOpener(opener)
}

func New(config *dag.Configuration, base v1.ImageIndex, archs []string, srcfs fs.FS) (v1.ImageIndex, error) {
	m, err := base.IndexManifest()
	if err != nil {
		return nil, err
	}

	wantArchs := map[string]struct{}{}
	for _, arch := range archs {
		wantArchs[types.ParseArchitecture(arch).ToAPK()] = struct{}{}
	}

	var idx v1.ImageIndex = empty.Index

	for _, desc := range m.Manifests {
		arch := types.ParseArchitecture(desc.Platform.Architecture).ToAPK()
		if _, ok := wantArchs[arch]; !ok {
			continue
		}

		baseImg, err := base.Image(desc.Digest)
		if err != nil {
			return nil, err
		}

		layer, err := layer(srcfs)
		if err != nil {
			return nil, err
		}

		img, err := mutate.AppendLayers(baseImg, layer)
		if err != nil {
			return nil, err
		}

		newDesc, err := partial.Descriptor(img)
		if err != nil {
			return nil, err
		}

		newDesc.Platform = desc.Platform

		idx = mutate.AppendManifests(idx, mutate.IndexAddendum{
			Add:        img,
			Descriptor: *newDesc,
		})
	}

	return idx, nil
}

// escapeRFC1123 escapes a string to be RFC1123 compliant.  We don't worry about
// being collision free because these are generally fed to generateName which
// appends a randomized suffix.
func escapeRFC1123(name string) string {
	return strings.ReplaceAll(strings.ReplaceAll(name, ".", "-"), "_", "-")
}

// Podspec returns bytes of yaml representing a podspec.
// This is a terrible API that we should change.
func Podspec(config *dag.Configuration, ref name.Reference, arch string) *corev1.Pod {
	resources := config.Package.Resources

	// Set some sane default resource requests if none are specified by flag or config.
	// This is required for GKE Autopilot.
	if resources.CPU == "0" {
		resources.CPU = "2"
	}
	if resources.Memory == "" {
		resources.Memory = "4Gi"
	}

	rr := corev1.ResourceRequirements{
		Requests: corev1.ResourceList{
			corev1.ResourceCPU:    resource.MustParse(resources.CPU),
			corev1.ResourceMemory: resource.MustParse(resources.Memory),
		},
	}

	pod := &corev1.Pod{
		ObjectMeta: metav1.ObjectMeta{
			GenerateName: fmt.Sprintf("melange-builder-%s-%s-", escapeRFC1123(config.Package.Name), arch),
			Namespace:    "default",
			Labels: map[string]string{
				"kubernetes.io/arch":             arch,
				"app.kubernetes.io/component":    config.Package.Name,
				"melange.chainguard.dev/arch":    types.Architecture(arch).ToOCIPlatform().Architecture,
				"melange.chainguard.dev/package": config.Package.Name,
			},
			Annotations: map[string]string{},
		},
		Spec: corev1.PodSpec{
			// Don't putz around for 30s when we kill things.
			TerminationGracePeriodSeconds: ptr.Int64(0),
			Containers: []corev1.Container{{
				Name:  "workspace",
				Image: ref.String(),
				// TODO: DO NOT SUBMIT: Do we need this?
				// ldconfig is run to prime ld.so.cache for glibc packages which require it.
				Command:      []string{"/bin/sh", "-c", "[ -x /sbin/ldconfig ] && /sbin/ldconfig /lib || true\nsleep infinity"},
				Resources:    rr,
				VolumeMounts: []corev1.VolumeMount{},
			}},
			RestartPolicy:                corev1.RestartPolicyNever,
			AutomountServiceAccountToken: ptr.Bool(false),
			NodeSelector: map[string]string{
				"kubernetes.io/arch": arch,
			},
			ServiceAccountName: "default",
			SecurityContext: &corev1.PodSecurityContext{
				SeccompProfile: &corev1.SeccompProfile{
					Type: corev1.SeccompProfileTypeRuntimeDefault,
				},
			},
			Volumes: []corev1.Volume{},
		},
	}

	for k, v := range config.Environment.Environment {
		pod.Spec.Containers[0].Env = append(pod.Spec.Containers[0].Env, corev1.EnvVar{
			Name:  k,
			Value: v,
		})
	}

	if pt := c.PodTemplate; pt != nil {
		if pt.Volumes != nil {
			pod.Spec.Volumes = append(pod.Spec.Volumes, pt.Volumes...)
		}

		if pt.VolumeMounts != nil {
			// Only mount to the workspace container
			pod.Spec.Containers[0].VolumeMounts = append(pod.Spec.Containers[0].VolumeMounts, pt.VolumeMounts...)
		}

		for k, v := range pt.NodeSelector {
			pod.Spec.NodeSelector[k] = v
		}

		if pt.Affinity != nil {
			pod.Spec.Affinity = pt.Affinity
		}

		if pt.RuntimeClassName != nil {
			pod.Spec.RuntimeClassName = pt.RuntimeClassName
		}

		if pt.Env != nil {
			pod.Spec.Containers[0].Env = append(pod.Spec.Containers[0].Env, pt.Env...)
		}

		if pt.ServiceAccountName != "" {
			pod.Spec.ServiceAccountName = pt.ServiceAccountName
		}
	}

	switch c.Provider {
	case "gke":
		// Be specific here, since not all regions support all compute classes
		// Ref: https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-compute-classes
		if cfg.Arch == apko_types.Architecture("arm64") {
			pod.Spec.NodeSelector["cloud.google.com/compute-class"] = "Scale-Out"
		}
	}

	return pod
}
